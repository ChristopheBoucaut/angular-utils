(function(angular) {
    "use strict";
    angular.module("cbAngular.utils", []);
})(window.angular);


(function(angular) {
    "use strict";

    var moduleStorage = angular.module("cbAngular.utils.storage", []);
    moduleStorage.factory("cbLocalStorage", [
        function() {
            return new Storage(window.localStorage);
        }
    ]);
    moduleStorage.factory("cbSessionStorage", [
        function() {
            return new Storage(window.sessionStorage);
        }
    ]);

    /**
     * Storage's constructor.
     * 
     * @param {object} _storageUsed Storage used for this object.
     *
     * @throws {StorageException} If storage is undefined.
     */
    function Storage(_storageUsed) {
        if (!_storageUsed) {
            throw new StorageException("The storage is undefined.");
        }

        this.getStorageUsed = function() {
            return _storageUsed;
        };
    }

    /**
     * Test if this namespace exist in the storage.
     * 
     * @param {string} namespace Namespace to be tested.
     * 
     * @return {boolean} If this namespace isn't saved in the storage, return false, else return true.
     */
    Storage.prototype.namespaceExist = function(namespace) {
        return this.getStorageUsed().getItem(namespace) === null ? false : true;
    };

    /**
     * Test if an item exists in the namespace.
     * 
     * @param {string} namespace Namespace where check if an item exists.
     * @param {string} key       Key to identify an item.
     * 
     * @return {boolean} If this item isn't saved in the namespace, return false, else return true.
     */
    Storage.prototype.itemExist = function(namespace, key) {
        var items = this.getItems(namespace);

        return items.hasOwnProperty(key);
    };

    /**
     * Clear the storage.
     */
    Storage.prototype.clearStorage = function() {
        this.getStorageUsed().clear();
    };

    /**
     * Clear the namespace.
     * 
     * @param {string} namespace Namespace to delete.
     */
    Storage.prototype.clearNamespace = function(namespace) {
        this.getStorageUsed().removeItem(namespace);
    };

    /**
     * Get all items saved in the namespace.
     * 
     * @param {string} namespace Namespace to get all items.
     * 
     * @return {object} Return an object with all items.
     */
    Storage.prototype.getItems = function(namespace) {
        var values = this.getStorageUsed().getItem(namespace);

        return values === null ? {} : JSON.parse(values);
    };

    /**
     * Get an item saved in a namespace.
     * 
     * @param {string} namespace    Namespace to get an item.
     * @param {string} key          Key to identify an item.
     * @param {mixed}  defaultValue If item isn't existed, return the defaultValue.
     * 
     * @return {mixed|undefined} Return the value or undefined.
     */
    Storage.prototype.getItem = function(namespace, key, defaultValue) {
        var items = this.getItems(namespace);
        var value;

        if (!items.hasOwnProperty(key) && defaultValue !== undefined) {
            value = defaultValue;
        } else if (items.hasOwnProperty(key)) {
            value = items[key];
        }

        return value;
    };

    /**
     * Count items in the namespace.
     * 
     * @param {string} namespace Namespace to count the items.
     * 
     * @return {integer} Return items number in the namespace. If namespaces isn't exist, return 0;
     */
    Storage.prototype.countItems = function(namespace) {
        if (this.namespaceExist(namespace)) {
            return Object.keys(this.getItems(namespace)).length;
        }

        return 0;
    };

    /**
     * Save an item in the namespace.
     * 
     * @param {string} namespace Namespace to save the item.
     * @param {string} key       Key to identify the item.
     * @param {mixed}  value     Item value.
     */
    Storage.prototype.setItem = function(namespace, key, value) {
        var items = this.getItems(namespace);
        items[key] = value;

        this.getStorageUsed().setItem(namespace, JSON.stringify(items));
    };

    /**
     * Delete an item in the namespace.
     * 
     * @param {string} namespace Namespace to delete the item.
     * @param {string} key       Key to identify the item.
     * 
     * @return {boolean} If success, return true, else return false.
     */
    Storage.prototype.removeItem = function(namespace, key) {
        var items = this.getItems(namespace);
        var deleteSuccessful = delete items[key];
        if (deleteSuccessful) {
            this.getStorageUsed().setItem(namespace, JSON.stringify(items));
        }

        return deleteSuccessful;
    };

    /**
     * Return the Storage's exception constructor.
     * 
     * @return {Function}
     */
    Storage.prototype.getException = function() {
        return StorageException;
    };

    /**
     * Exception for storage object.
     * 
     * @param {string} message Error message.
     */
    function StorageException(message) {
        this.name = "StorageException";
        this.message = message;
    }

    moduleStorage.constant("cbStorageConstructor", Storage);
})(window.angular);


(function(angular) {
    "use strict";

    var moduleCache = angular.module("cbAngular.utils.cache", [
        "cbAngular.utils.storage"
    ]);
    moduleCache.provider("cbSessionCache", [
        function() {
            var namespaceStorage = "Cache";

            this.setNamespaceStorage = function(name) {
                namespaceStorage = name;
            };

            this.$get = [
                "cbSessionStorage",
                function (cbSessionStorage) {
                    return new Cache(cbSessionStorage, name);
                }
            ];
        }
    ]);

    moduleCache.provider("cbPersistentCache", [
        function() {
            var namespaceStorage = "Cache";

            this.setNamespaceStorage = function(name) {
                namespaceStorage = name;
            };

            this.$get = [
                "cbLocalStorage",
                function (cbLocalStorage) {
                    return new Cache(cbLocalStorage, namespaceStorage);
                }
            ];
        }
    ]);

    /**
     * Cache's constructor.
     * 
     * @param {object} _storageService   Service angularJS to manage the saved cache.
     * @param {string} _namespaceStorage Namespace to storage the cache.
     *
     * @throws {CacheException} If storage is undefined or not instance of Storage.
     * @throws {CacheException} If namespace storage is undefined or empty.
     */
    function Cache(_storageService, _namespaceStorage) {
        var StorageConstructor = moduleCache.constant("cbStorageConstructor");
        if (!_storageService || !(_storageService instanceof StorageConstructor)) {
            throw new CacheException("The storage service is undefined or not instance of Storage.");
        }

        if (!_namespaceStorage || _namespaceStorage === "") {
            throw new CacheException("The cache need a storage namespace.");
        }

        this.getStorageService = function() {
            return _storageService;
        };

        this.getNamespaceStorage = function() {
            return _namespaceStorage;
        };
    }

    /**
     * Try to generate an object for the storage. Use getter methods and public attributes.
     * 
     * @param {object} obj [description]
     * 
     * @return {object}
     *
     * @throws {CacheException} If First argument isn't an object.
     */
    Cache.prototype.generateObjectForStorageWithGetter = function(obj) {
        if (!(obj instanceof Object)) {
            throw new CacheException("First argument of generateObjectForStorageWithGetter method must be an object.");
        }

        var objReturn = {};
        for (var nameFnt in obj) {
            if (obj[nameFnt] instanceof Function) {
                var nameVar = nameFnt.match(/^get(.*)/);
                if (nameVar.length < 2) {
                    continue;
                }

                nameVar = nameVar[1].charAt(0).toLowerCase() + nameVar.slice(1);

                // if the getter has got arguments, ignore it.
                if (!obj[nameFnt].toString().match(/^function[^\(]*\(\)/)) {
                    continue;
                }

                objReturn[nameVar] = obj[nameFnt]();
            } else {
                objReturn[nameFnt] = obj[nameFnt];
            }
        }

        return objReturn;
    };

    /**
     * Save an element in the cache.
     * 
     * @param {string}  key   Cache Key.
     * @param {mixed}   value Cached value.
     * @param {integer} ttl   Time to live in seconds.
     */
    Cache.prototype.put = function(key, value, ttl) {
        var dateExpire = new Date();
        dateExpire.setSeconds(dateExpire.getSeconds() + ttl);
        this.getStorageService().setItem(this.getNamespaceStorage(), key, new CacheContainer(value, dateExpire));
    };

    /**
     * Check if this key is present in cache.
     * 
     * @param {string} key Key to search in the cache.
     * 
     * @return {Boolean} True if it's present, else false.
     */
    Cache.prototype.isCached = function(key) {
        return this.getStorage().itemExist(this.getNamespaceStorage(), key);
    };

    /**
     * Check if this key references a expired value.
     * 
     * @param {string} key Key to search in the cache.
     * 
     * @return {Boolean} True if it isn't present or value is expired, else false.
     */
    Cache.prototype.isExpired = function(key) {
        if (!this.isCached(key)) {
            return true;
        }

        var itemCached = this.getStorage().getItem(this.getNamespaceStorage(), key);
        var container = new CacheContainer(itemCached.value, new Date(itemCached.dateExpire));

        return container.isExpired();
    };

    /**
     * Get the value cached referenced by the key.
     * 
     * @param {string} key Key to search the value.
     * 
     * @return {mixed}
     */
    Cache.prototype.get = function(key) {
        if (!this.isCached(key)) {
            throw new CacheException("Key is not cached.");
        }

        var item = this.getStorage().getItem(this.getNamespaceStorage(), key);
        var container = new CacheContainer(item.value, new Date(item.dateExpire));

        if (container.isExpired()) {
            throw new CacheException("Value referenced by '"+key+"' key is expired."); 
        }

        return container.value;
    };

    /**
     * Remove the value referenced by the key.
     * 
     * @param {string} key Key to delete the value.
     * 
     * @return {Boolean} True if the deletion is successful, else false.
     */
    Cache.prototype.remove = function(key) {
        return this.getStorageService().removeItem(this.getNamespaceStorage(), key);
    };

    /**
     * Remove all cached values.
     */
    Cache.prototype.removeAll = function() {
        this.getStorageService().clearNamespace(this.getNamespaceStorage());
    };

    /**
     * Remove the expired values.
     * 
     * @return {integer} Return count of deleted values.
     *
     * @throws {CacheException} If the deletion is failed for one value.
     */
    Cache.prototype.clean = function() {
        var items = this.getStorageService().getItems(this.getNamespaceStorage());
        var countValuesDeleted = 0;
        for (var key in items) {
            var container = new CacheContainer(items[key].value, new Date(items[key].dateExpire));
            if (container.isExpired()) {
                if (!this.remove(key)) {
                    throw new CacheException("Fail to clean the cache. Fail to '"+key+"' key.");
                }
                countValuesDeleted++;
            }
        }

        return countValuesDeleted;
    };

    /**
     * Count the total cached values.
     * 
     * @return {integer}
     */
    Cache.prototype.countValuesCached = function() {
        return this.getStorageService().countItems(this.getNamespaceStorage());
    };

    /**
     * Return the Cache's exception constructor.
     * 
     * @return {Function}
     */
    Cache.prototype.getException = function() {
        return CacheException;
    };

    /**
     * Return the Cache's container constructor.
     * 
     * @return {Function}
     */
    Cache.prototype.getContainer = function() {
        return CacheContainer;
    };

    /**
     * CacheContainer's constructor.
     * 
     * @param {mixed} value      Value to cached.
     * @param {Date}  dateExpire Date to invalidate the cache.
     *
     * @throws {CacheContainerException} If dateExpire isn't Date object.
     */
    function CacheContainer(value, dateExpire) {
        if (!(dateExpire instanceof Date)) {
            throw new CacheContainerException("Second argument to create a new CacheContainer must be a Date object. "+dateExpire.constructor.name+" object given.");
        }
        this.value = value;
        this.dateExpire = dateExpire;
    }

    /**
     * Check this cache is expired or not for now.
     * 
     * @return {Boolean} True: expired, else false.
     */
    CacheContainer.prototype.isExpired = function() {
        return this.dateExpire < new Date();
    };

    /**
     * Return the CacheContainer's exception constructor.
     * 
     * @return {Function} 
     */
    CacheContainer.prototype.getException = function() {
        return CacheContainerException;
    };

    /**
     * Exception for cache object.
     * 
     * @param {string} message Error message.
     */
    function CacheException(message) {
        this.name = "CacheException";
        this.message = message;
    }

    /**
     * Exception for cacheContainer object.
     * 
     * @param {string} message Error message.
     */
    function CacheContainerException(message) {
        this.name = "CacheContainerException";
        this.message = message;
    }

    moduleCache.constant("cbCacheConstructor", Cache);
})(window.angular);


(function(angular) {
    "use strict";

    var modelModule = angular.module("cbAngular.utils.modelManager", [
        "cbAngular.utils.cache"
    ]);

    modelModule.provider("cbModelManager", [
        function() {
            var baseUrlApi;

            /**
             * Set the base url to request the API.
             * 
             * @param {string} newBaseUrlApi
             */
            this.setBaseUrlApi = function(newBaseUrlApi) {
                baseUrlApi = newBaseUrlApi;
            };

            this.$get = [
                "$http",
                "cbCacheConstructor",
                function($http, cbCacheConstructor) {
                    return new ModelManager(baseUrlApi, $http, cbCacheConstructor);
                }
            ];
        }
    ]);

    /**
     * Class to the service.
     */
    function ModelManager(_baseUrlApi, _httpService, _cacheConstructor) {
        var _models = {};
        var _cacheService;

        this.setBaseUrlApi = function(baseUrlApi) {
            _baseUrlApi = baseUrlApi;
        };
        this.getBaseUrlApi = function() {
            return _baseUrlApi;
        };
        this.setHttpService = function(httpService) {
            _httpService = httpService;
        };
        this.getHttpService = function() {
            return _httpService;
        };
        this.setCacheService = function(cacheService) {
            _cacheService = cacheService;
        };
        this.getCacheService = function() {
            return _cacheService;
        };
        this.getModels = function() {
            return _models;
        };

        /**
         * Register a new model.
         * 
         * @param {Model} model New model to register.
         */
        this.registerModel = function(model) {
            if (!(model.prototype instanceof Model)) {
                var nameObj = model.name === undefined ? model.constructor.name : model.name;
                throw new ModelManagerException("The first agrument of registerModel must be a Model object. Receive "+nameObj+" object");
            }
            if (model.prototype.typeApi === undefined) {
                throw new ModelManagerException("The model "+model.name+" need to override the variable class named 'typeApi'.");
            }

            _models[model.name] = model;
        };

        /**
         * To get the model constructor by its name.
         * 
         * @param {string} name The model's name.
         * 
         * @return {Function} Return the constructor.
         *
         * @throws {ModelManagerException} If model isn't found.
         */
        this.getModelByName = function(name) {
            if (!_models.hasOwnProperty(name)) {
                throw new ModelManagerException("The model : '"+name+"' is not registered.");
            }

            return _models[name];
        };

        /**
         * Create an object for a new model's prototype.
         * 
         * @param {string} type Model's type to build the url api.
         * 
         * @return {Object}
         *
         * @throws {ModelManagerException} If cache object isn't defined or it isn't instance of GeneanetCache.
         */
        this.createPrototype = function(type) {
            if (!(_cacheService instanceof _cacheConstructor)) {
                if (_cacheService !== undefined) {
                    throw new ModelManagerException("Need a "+_cacheConstructor.name+" object to use cache. Set with setCache(yourcache).");
                } else {
                    throw new ModelManagerException("Set a cache to use : GeneanetModelManager.setCache(yourCache).");
                }
            }

            return Object.create(Model.prototype, {
                type: {
                    value: type
                },
                baseUrlApi: {
                    value: _baseUrlApi
                },
                cacheService: {
                    value: _cacheService
                },
                httpService: {
                    value: _httpService
                }
            });
        };
    }

    /**
     * Return ModelManager's exception construtor.
     * 
     * @return {Function}
     */
    ModelManager.prototype.getException = function() {
        return ModelManagerException;
    };

    /**
     * Return the configuration http constructor.
     * 
     * @return {Function}
     */
    ModelManager.prototype.getModelConfigurationHttp = function() {
        return ModelConfigurationHttp;
    };

    /**
     * Class parent to future models.
     */
    function Model() {}

    // First element in the api url.
    Model.prototype.typeApi = undefined;
    // base url api.
    Model.prototype.baseUrlApi = undefined;
    // Cache object used.
    Model.prototype.cacheService = undefined;
    // Http object to request the API.
    Model.prototype.httpService = undefined;

    /**
     * Send a request at API.
     * 
     * @param {ModelConfigurationHttp} configuration Configuration to request api.
     * 
     * @return {Promise} Return a promise object to add action on event finished.
     *
     * @throws {ModelException} If configuration isn't instance of ModelConfigurationHttp.
     * @throws {ModelException} If configuration.methodHttp doesn't exist in httpService object.
     */
    Model.prototype.http = function(configurationHttp) {
        // check configuration's type.
        if (!(configurationHttp instanceof ModelConfigurationHttp)) {
            throw new ModelException("First parameter of http() method must be a ModelConfigurationHttp object but receive a '"+configurationHttp.constructor.name+"' object.");
        }

        // check method to request the API exists.
        var methodHttp = configurationHttp.getMethodHttp().toLowerCase();
        if (!this.httpService.hasOwnProperty(methodHttp)) {
            throw new ModelException((this.httpService.name ? this.httpService.name : this.httpService.constructor.name)+" object doesn't know the method : "+methodHttp);
        }

        var fullUrlApi = this.baseUrlApi+"/"+this.typeApi+"/"+configurationHttp.getActionUrl();

        var promiseRequestHttp;
        if (methodHttp === "get") {
            fullUrlApi = fullUrlApi+"?"+configurationHttp.buildDatas("&");
            promiseRequestHttp = this.requestHttp[methodHttp](fullUrlApi);
        } else {
            promiseRequestHttp = this.requestHttp[methodHttp](fullUrlApi, configurationHttp.getDatas());
        }

        return promiseRequestHttp;
    };

    /**
     * To request the api.
     * 
     * @param {ModelConfigurationHttp} configuration   Configuration to build the correct request at API.
     * @param {Function|undefined}     successCallback Method called if the request is successful.
     * @param {Function|undefined}     failCallback    Method called if the request is failed.
     * @param {Boolean}                refresh         Flag to force request the api (true) or allow request the cache (false).
     * 
     * @throws {ModelException} If configuration object isn't instance of ModelConfigurationHttp.
     */
    Model.prototype.requestApi = function(configuration, successCallback, failCallback, refresh) {
        successCallback = successCallback instanceof Function ? successCallback : undefined;
        failCallback = failCallback instanceof Function ? failCallback : undefined;
        refresh = refresh ? refresh : false;

        // check configuration's type.
        if (!(configuration instanceof ModelConfigurationHttp)) {
            throw new ModelException("The first parameter of requestApi method must be a ModelConfigurationHttp object but receive a '"+configuration.controller.name+"' object.");
        }

        // Not use cache.
        if (configuration.getTtlCache() === undefined) {
            this.http(configuration).then(
                function(data) {
                    if (successCallback) {
                        successCallback(data.data, data.status);
                    }
                },
                function(data) {
                    if (failCallback) {
                        failCallback(data.data, data.status);
                    }
                }
            );
        } else {
            var keyCache = configuration.buildKeyCache();
            // not force refresh and cache is valid.
            if (!refresh && !this.cacheService.isExpired(keyCache)) {
                if (successCallback) {
                    var datasFromCache = this.cacheService.get(keyCache);
                    successCallback(datasFromCache.data, datasFromCache.status);
                }
            } else {
                // force refresh or cache expired.
                var selfModel = this;
                this.http(configuration).then(
                    function(data) {
                        // cache new value.
                        selfModel.cacheService.put(keyCache, data, configuration.getTtlCache());
                        if (successCallback) {
                            successCallback(data.data, data.status);
                        }
                    },
                    function(data) {
                        if (failCallback) {
                            failCallback(data.data, data.status);
                        }
                    }
                );
            }
        }
    };

    /**
     * Return Model's exception construtor.
     * 
     * @return {Function}
     */
    Model.prototype.getException = function() {
        return ModelException;
    };

    /**
     * Configuration class to execute Model's http method.
     * 
     * @param {string}            _methodHttp Http method to request API (eg: 'post', 'put', etc).
     * @param {string}            _actionUrl  Action name api. Used to build the url api.
     * @param {Object}            _datas      Parameters to request the API.
     * @param {integer|undefined} _ttlCache   Time To Live for the cache. If it isn't defined, don't use the cache.
     */
    function ModelConfigurationHttp(_methodHttp, _actionUrl, _datas, _ttlCache) {
        this.getMethodHttp = function() {
            return _methodHttp;
        };
        this.setMethodHttp = function(methodHttp) {
            _methodHttp = methodHttp;
        };
        this.getActionUrl = function() {
            return _actionUrl;
        };
        this.setActionUrl = function(actionUrl) {
            _actionUrl = actionUrl;
        };
        this.getDatas = function() {
            return _datas;
        };
        this.setDatas = function(datas) {
            _datas = datas;
        };
        this.getTtlCache = function() {
            return _ttlCache;
        };
        this.setTtlCache = function(ttlCache) {
            _ttlCache = ttlCache;
        };
    }

    /**
     * Join configuration's datas with a glue string. Used for build url API in get mode.
     * 
     * @param {string} glue String used to build the parameters string.
     * 
     * @return {string} Parameters string.
     */
    ModelConfigurationHttp.prototype.buildDatas = function(glue) {
        var params = [];
        for (var nameParam in this.getDatas()) {
            var valueParam = this.getDatas()[nameParam];
            if (valueParam === undefined || valueParam === null) {
                continue;
            }
            if (valueParam instanceof Array) {
                for (var i = 0; i < valueParam.length; i++) {
                    params.push(nameParam+"[]="+encodeURIComponent(valueParam[i]));
                }
            } else if (valueParam instanceof Object) {
                for (var nameKey in valueParam) {
                    params.push(nameParam+"["+nameKey+"]="+encodeURIComponent(valueParam[nameKey]));
                }
            } else {
                params.push(nameParam+"="+encodeURIComponent(valueParam));
            }
        }

        return params.join(glue);
    };

    /**
     * Build a key for the cache.
     * 
     * @return {string} Cache key.
     */
    ModelConfigurationHttp.prototype.buildKeyCache = function() {
        return this.getMethodHttp()+"_"+this.getActionUrl()+"_"+this.buildDatas("_");
    };

    /**
     * Return ModelConfigurationHttp's exception construtor.
     * 
     * @return {Function}
     */
    ModelConfigurationHttp.prototype.getException = function() {
        return ModelConfigurationHttpException;
    };

    /**
     * ModelManager's exception.
     * 
     * @param {string} message Error message.
     */
    function ModelManagerException(message) {
        this.message = message;
        this.name = "ModelManagerException";
    }

    /**
     * Model's exception.
     * 
     * @param {string} message Error message.
     */
    function ModelException(message) {
        this.message = message;
        this.name = "ModelException";
    }

    /**
     * ModelConfigurationHttp's exception.
     * 
     * @param {string} message Error message.
     */
    function ModelConfigurationHttpException(message) {
        this.message = message;
        this.name = "ModelConfigurationHttpException";
    }
})(window.angular);
